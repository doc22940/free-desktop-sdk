"""Downloads CVE database and store it as sqlite3 database.

This tool does not take parameter. It will create files in the current
directory:
 - data.db: The sqlite3 database itself.
 - nvdcve-2.0-*.xml.gz: The cached raw XML databases from the CVE database.

Do not remove nvdcve-2.0-*.xml.gz files unless you remove
data.db. data.db contains etags, and files would not be downloaded
again if files are just removed.

Files are not downloaded if not modified. But we still verify with the
remote database we have the latest version of the files.
"""

import gzip
import sqlite3
import datetime
import urllib.request
import urllib.parse
from contextlib import contextmanager, ExitStack
import signal
import socket

from lxml import etree as ET

NAMESPACES = {
    "feed": "http://scap.nist.gov/schema/feed/vulnerability/2.0",
    "vuln": "http://scap.nist.gov/schema/vulnerability/0.4",
    "cvss": "http://scap.nist.gov/schema/cvss-v2/0.2",
}

def extract_vulns(tree):
    """
    :param tree:    
    :type tree:     xml.etree.ElementTree

    :returns:   
    :rtype:     
    """
    for entry in tree.iterfind("feed:entry", namespaces=NAMESPACES):
        cve_id = entry.find("vuln:cve-id", namespaces=NAMESPACES).text
        summary = entry.find("vuln:summary", namespaces=NAMESPACES).text
        score = entry.find("vuln:cvss/cvss:base_metrics/cvss:score", namespaces=NAMESPACES)
        yield cve_id, summary, score.text if score is not None else None

def extract_product_vulns(tree):
    """
    :param tree:    
    :type tree:     xml.etree.ElementTree

    :returns:   
    :rtype:     
    """
    for entry in tree.iterfind("feed:entry", namespaces=NAMESPACES):
        cve_id = entry.find("vuln:cve-id", namespaces=NAMESPACES).text
        for vuln_software in entry.iterfind("vuln:vulnerable-software-list", namespaces=NAMESPACES):
            for product in vuln_software.iterfind("vuln:product", namespaces=NAMESPACES):
                product_name = product.text
                try:
                    vendor, name, version = product_name.split(':')[2:5]
                except ValueError:
                    continue
                yield cve_id, vendor, name, version

def ensure_tables(cursor_args):
    cursor_args.execute("""CREATE TABLE IF NOT EXISTS etags
                 (year TEXT UNIQUE, etag TEXT)""")
    cursor_args.execute("""CREATE TABLE IF NOT EXISTS cve
                 (id TEXT UNIQUE, summary TEXT, score TEXT)""")
    cursor_args.execute("""CREATE TABLE IF NOT EXISTS product_vuln
                 (cve_id TEXT, name TEXT, vendor TEXT, version TEXT,
                  UNIQUE(cve_id, name, vendor, version))""")


class UrlOpenTimeout:

    def __init__(self):
        self._max = 120
        self._min = 5
        self._timeout = self._max

    @contextmanager
    def open(self, req):
        """
        :param req: the URL you want to open TODO check
        :type req:  str TODO check

        :raises TimeoutError:   if it takes too long to connect TODO better?
        :raises URLError:       if the URL is not valid TODO check

        :returns:   
        :rtype:     ExitStack   TODO check
        """
        with ExitStack() as stack:
            def _timeout(signum, frame):
                raise TimeoutError()
            try:
                signal.signal(signal.SIGALRM, _timeout)
                signal.alarm(self._timeout)
                resp = stack.enter_context(urllib.request.urlopen(req, timeout=self._timeout))
                self._timeout = self._max
            except TimeoutError:
                self._timeout = max(int(self._timeout/2), self._min)
                raise
            except urllib.error.URLError as exception:
                if isinstance(exception.reason, socket.timeout):
                    self._timeout = max(int(self._timeout/2), self._min)
                    raise TimeoutError()
                raise
            finally:
                signal.alarm(0)

            yield resp

def update_year(cursor, updated_year, url_timeout):
    """
    :param cursor:          the database we want to access TODO check
    :type cursor:           Cursor
    :param updated_year:    the updated year we want to get our database records TODO check
    :type updated_year:     str
    :param url_timeout:     the maximum amount of time allowed to connect to the URL TODO check
    :type url_timeout:      UrlOpenTimeout

    :raises TimeoutError:   TODO check
    :raises HTTPError:      TODO check, also expand raise to urllib.error
    """
    url = 'https://nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-{}.xml.gz'.format(updated_year)
    cursor.execute("SELECT etag FROM etags WHERE year=?", (updated_year,))
    row = cursor.fetchone()
    if row is not None:
        etag = row[0]
    else:
        etag = None

    request = urllib.request.Request(url)
    if etag is not None:
        request.add_header('If-None-Match', etag)
        url_opener = url_timeout.open
    else:
        url_opener = urllib.request.urlopen
    try:
        with url_opener(request) as resp:
            new_etag = resp.getheader('ETag')
            assert new_etag is not None
            if new_etag is not None:
                cursor.execute("INSERT OR REPLACE INTO etags (year, etag) VALUES (?, ?)", (year, new_etag))
            with open('nvdcve-2.0-{}.xml.gz'.format(year), 'wb') as file:
                while True:
                    buf = resp.read(4096)
                    if not buf:
                        print("Downloaded {}".format(file.name))
                        break
                    file.write(buf)
    except TimeoutError:
        if etag is None:
            raise
        print("Timeout, using cache for {}".format('nvdcve-2.0-{}.xml.gz'.format(year)))
    except urllib.error.HTTPError as error:
        if error.code != 304:
            raise
        print("Cached {}".format('nvdcve-2.0-{}.xml.gz'.format(year)))

    with gzip.open('nvdcve-2.0-{}.xml.gz'.format(year)) as file:
        tree = ET.parse(file)
        for cve_id, summary, score in extract_vulns(tree):
            cursor.execute("INSERT OR REPLACE INTO cve (id, summary, score) VALUES (?, ?, ?)", (cve_id, summary, score))

        for cve_id, vendor, name, version in extract_product_vulns(tree):
            cursor.execute("INSERT OR REPLACE INTO product_vuln (cve_id, name, vendor, version) VALUES (?, ?, ?, ?)", (cve_id, name, vendor, version))

if __name__ == '__main__':
    # FIXME does other CONNECTION need closing
    CONNECTION = sqlite3.connect('data-2.db')
    CURSOR = CONNECTION.cursor()
    #FIXME no except
    try:
        ensure_tables(CURSOR)
        URL_TIMEOUT = UrlOpenTimeout()
        for year in range(2002, datetime.datetime.now().year + 1):
            update_year(CURSOR, str(year), URL_TIMEOUT)
        update_year(CURSOR, 'Modified', URL_TIMEOUT)
        CONNECTION.commit()
    finally:
        CONNECTION.close()
